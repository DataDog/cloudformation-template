AWSTemplateFormatVersion: "2010-09-09"
Description: Calls the Datadog Agentless Scanning API to enable or disable agentless scanning features.

Parameters:
  DatadogAPIKey:
    Type: String
    AllowedPattern: "[0-9a-f]{32}"
    Description: API key for the Datadog account
    NoEcho: true

  DatadogAPPKey:
    Type: String
    AllowedPattern: "[0-9a-f]{40}"
    Description: Application key for the Datadog account
    NoEcho: true

  DatadogSite:
    Type: String
    Description: The Datadog site to use for the Datadog Agentless Scanner
    Default: datadoghq.com
    AllowedValues:
      - datadoghq.com
      - datadoghq.eu
      - us3.datadoghq.com
      - us5.datadoghq.com
      - ap1.datadoghq.com
      - ap2.datadoghq.com

  AgentlessHostScanning:
    Type: String
    AllowedValues:
      - true
      - false
    Description: Enable Agentless Scanning of host vulnerabilities.
    Default: false

  AgentlessContainerScanning:
    Type: String
    AllowedValues:
      - true
      - false
    Description: Enable Agentless Scanning of container vulnerabilities.
    Default: false

  AgentlessLambdaScanning:
    Type: String
    AllowedValues:
      - true
      - false
    Description: Enable Agentless Scanning of Lambda vulnerabilities.
    Default: false

  AgentlessSensitiveDataScanning:
    Type: String
    AllowedValues:
      - true
      - false
    Description: Enable Agentless Scanning of datastores (S3 buckets).
    Default: false

Resources:
  LambdaExecutionRoleDatadogAgentlessAPICall:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"

  DatadogAgentlessAPICall:
    Type: "Custom::DatadogAgentlessAPICall"
    Properties:
      ServiceToken: !GetAtt "DatadogAgentlessAPICallFunction.Arn"
      APIKey: !Ref "DatadogAPIKey"
      APPKey: !Ref "DatadogAPPKey"
      DatadogSite: !Ref "DatadogSite"
      AccountId: !Ref "AWS::AccountId"
      Hosts: !Ref "AgentlessHostScanning"
      Containers: !Ref "AgentlessContainerScanning"
      Lambdas: !Ref "AgentlessLambdaScanning"
      SensitiveData: !Ref "AgentlessSensitiveDataScanning"

  DatadogAgentlessAPICallFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: A function to call the Datadog Agentless API.
      Role: !GetAtt LambdaExecutionRoleDatadogAgentlessAPICall.Arn
      Handler: "index.handler"
      LoggingConfig:
        ApplicationLogLevel: "INFO"
        LogFormat: "JSON"
      Runtime: "python3.11"
      Timeout: 30
      Code:
        ZipFile: |
          import boto3

          import json
          import logging
          import signal
          from urllib.request import build_opener, HTTPHandler, HTTPError, Request
          import urllib.parse

          LOGGER = logging.getLogger()

          API_CALL_SOURCE_HEADER_VALUE = "cfn-agentless-quick-start"

          def call_datadog_agentless_api(event, method):
              api_key = event['ResourceProperties']['APIKey']
              app_key = event['ResourceProperties']['APPKey']
              dd_site = event['ResourceProperties']['DatadogSite']
              account_id = event['ResourceProperties']['AccountId']
              hosts = event['ResourceProperties']['Hosts']
              containers = event['ResourceProperties']['Containers']
              lambdas = event['ResourceProperties']['Lambdas']
              sensitive_data = event['ResourceProperties']['SensitiveData']

              # Make the url Request
              url = 'https://api.' + dd_site + '/api/v2/agentless_scanning/accounts/aws'
              headers = {
                  'DD-API-KEY': api_key,
                  'DD-APPLICATION-KEY': app_key,
                  'Dd-Call-Source': API_CALL_SOURCE_HEADER_VALUE,
              }

              if method == "DELETE":
                  url = url + '/' + account_id
                  request = Request(url, headers=headers)
                  request.get_method = lambda: method
                  try:
                    return urllib.request.urlopen(request)
                  except HTTPError as e:
                    if e.code != 404:
                      raise e
                    else:
                      return e
              elif method == "POST":
                  values = {
                      "data": {
                          "id": account_id,
                          "type": "aws_scan_options",
                          "attributes": {
                              "vuln_containers_os": containers == 'true',
                              "vuln_host_os": hosts == 'true',
                              "lambda": lambdas == 'true',
                              "sensitive_data": sensitive_data == 'true',
                          }
                      }
                  }
                  data = json.dumps(values)
                  data = data.encode('utf-8')  # data should be bytes
                  url_account_id = url + '/' + account_id
                  if is_agentless_scanning_enabled(url_account_id, headers):
                      request = Request(url_account_id, data=data, headers=headers)
                      request.get_method = lambda: 'PATCH'
                  else:
                      request = Request(url, data=data, headers=headers)
                      request.get_method = lambda: 'POST'
                  request.add_header('Content-Type', 'application/vnd.api+json; charset=utf-8')
                  request.add_header('Content-Length', len(data))
                  response = urllib.request.urlopen(request)
                  return response
              else:
                  LOGGER.error('Unsupported HTTP method.')
                  return None

          def is_agentless_scanning_enabled(url_account_id, headers):
              '''Check if agentless scanning is already enabled for the account'''
              try:
                request = Request(url_account_id, headers=headers)
                request.get_method = lambda: 'GET'
                response = urllib.request.urlopen(request)
                return response.getcode() == 200
              except HTTPError as e:
                if e.code != 404:
                  raise e
                return False

          def handler(event, context):
              '''Handle Lambda event from AWS'''
              try:
                  if event['RequestType'] == 'Create':
                      LOGGER.info('Received Create request.')
                      response = call_datadog_agentless_api(event, 'POST')
                      if response.getcode() == 201 or response.getcode() == 204:
                          send_response(event, context, "SUCCESS",
                                        {
                                            "Message": "Datadog AWS Agentless Scanning Integration created successfully.",
                                        })
                      else:
                          LOGGER.error('Failed - unexpected status code: %d', response.getcode())
                          send_response(event, context, "FAILED", {
                              "Message": "Http response: {}".format(response.msg)})

                  elif event['RequestType'] == 'Update':
                      LOGGER.info('Received Update request.')
                      send_response(event, context, "SUCCESS",
                                    {"Message": "Update not supported, no operation performed."})
                  elif event['RequestType'] == 'Delete':
                      LOGGER.info('Received Delete request.')
                      response = call_datadog_agentless_api(event, 'DELETE')

                      if response.getcode() == 200:
                          send_response(event, context, "SUCCESS",
                                        {
                                            "Message": "Datadog AWS Agentless Scanning Integration deleted successfully.",
                                        })
                      else:
                          LOGGER.error('Failed - unexpected status code: %d', response.getcode())
                          send_response(event, context, "FAILED", {
                              "Message": "Http response: {}".format(response.msg)})

                  else:
                      LOGGER.error('Failed - received unexpected request: %s', event['RequestType'])
                      send_response(event, context, "FAILED",
                                    {"Message": "Unexpected event received from CloudFormation"})
              except Exception as e:  # pylint: disable=W0702
                  LOGGER.exception('Failed - exception thrown during processing.')
                  send_response(event, context, "FAILED", {
                      "Message": "Exception during processing: {}".format(e)})


          def send_response(event, context, response_status, response_data):
              '''Send a resource manipulation status response to CloudFormation'''
              response_body = json.dumps({
                  "Status": response_status,
                  "Reason": "See the details in CloudWatch Log Stream: " + context.log_stream_name,
                  "PhysicalResourceId": context.invoked_function_arn,
                  "StackId": event['StackId'],
                  "RequestId": event['RequestId'],
                  "LogicalResourceId": event['LogicalResourceId'],
                  "Data": response_data
              })
              formatted_response = response_body.encode("utf-8")

              LOGGER.info('ResponseURL: %s', event['ResponseURL'])
              LOGGER.info('ResponseBody: %s', response_body)

              opener = build_opener(HTTPHandler)
              request = Request(event['ResponseURL'], data=formatted_response)
              request.add_header('Content-Type', 'application/json; charset=utf-8')
              request.add_header('Content-Length', len(formatted_response))
              request.get_method = lambda: 'PUT'
              response = opener.open(request)
              LOGGER.info("Status code: %s", response.getcode())
              LOGGER.info("Status message: %s", response.msg)


          def timeout_handler(_signal, _frame):
              '''Handle SIGALRM'''
              raise Exception('Time exceeded')


          signal.signal(signal.SIGALRM, timeout_handler)
