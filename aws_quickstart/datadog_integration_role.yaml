AWSTemplateFormatVersion: 2010-09-09
Description: IAM role for Datadog AWS Integration
Parameters:
  ExternalId:
    Description: >-
      External ID for the Datadog role (generate at
      https://app.datadoghq.com/account/settings#integrations/amazon-web-services)
    Type: String
  IAMRoleName:
    Description: Customize the name of IAM role for Datadog AWS integration
    Type: String
    Default: DatadogIntegrationRole
  ResourceCollectionPermissions:
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
    Description: >-
      Set this value to "true" to add permissions for Datadog to collect resource configuration data.
  DdAWSAccountId:
    Description: >-
      Datadog AWS account ID allowed to assume the integration IAM role. DO NOT CHANGE!
    Type: String
    Default: "464622532012"
Conditions:
  ShouldInstallSecurityAuditPolicy:
    Fn::Equals:
      - Ref: ResourceCollectionPermissions
      - true
Resources:
  DatadogIntegrationRole:
    Type: "AWS::IAM::Role"
    Metadata:
      cfn-lint:
        config:
          # cfn-lint does not yet support "Fn::Transform"
          # This policy needs broad read permissions to allow Datadog to collect metrics and metadata
          ignore_checks:
            - E3002
            - E3003
            - EIAMPolicyActionWildcard
            - EIAMPolicyWildcardResource
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:${AWS::Partition}:iam::${DdAWSAccountId}:root"
            Action:
              - "sts:AssumeRole"
            Condition:
              StringEquals:
                "sts:ExternalId": !Ref ExternalId
      Path: /
      RoleName: !Ref IAMRoleName
      ManagedPolicyArns:
        !If [
          ShouldInstallSecurityAuditPolicy,
          [!Sub "arn:${AWS::Partition}:iam::aws:policy/SecurityAudit"],
          !Ref AWS::NoValue,
        ]
      Policies:
        - PolicyName: DatadogAWSIntegrationPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Resource: "*"
                Action:
                  - "account:GetAccountInformation"
                  - "airflow:GetEnvironment"
                  - "airflow:ListEnvironments"
                  - "apigateway:GET"
                  - "appsync:ListGraphqlApis"
                  - "autoscaling:Describe*"
                  - "backup:List*"
                  - "batch:DescribeJobDefinitions"
                  - "bcm-data-exports:GetExport"
                  - "bcm-data-exports:ListExports"
                  - "budgets:ViewBudget"
                  - "cloudfront:GetDistributionConfig"
                  - "cloudfront:ListDistributions"
                  - "cloudtrail:DescribeTrails"
                  - "cloudtrail:GetTrail"
                  - "cloudtrail:GetTrailStatus"
                  - "cloudtrail:ListTrails"
                  - "cloudtrail:LookupEvents"
                  - "cloudwatch:Describe*"
                  - "cloudwatch:Get*"
                  - "cloudwatch:List*"
                  - "codebuild:BatchGetProjects"
                  - "codebuild:ListProjects"
                  - "codedeploy:BatchGet*"
                  - "codedeploy:List*"
                  - "cur:DescribeReportDefinitions"
                  - "directconnect:Describe*"
                  - "dms:DescribeReplicationInstances"
                  - "dynamodb:Describe*"
                  - "dynamodb:List*"
                  - "ec2:Describe*"
                  - "ecs:Describe*"
                  - "ecs:List*"
                  - "eks:DescribeCluster"
                  - "eks:ListClusters"
                  - "elasticache:Describe*"
                  - "elasticache:List*"
                  - "elasticfilesystem:DescribeAccessPoints"
                  - "elasticfilesystem:DescribeFileSystems"
                  - "elasticfilesystem:DescribeTags"
                  - "elasticloadbalancing:Describe*"
                  - "elasticmapreduce:Describe*"
                  - "elasticmapreduce:List*"
                  - "es:DescribeElasticsearchDomains"
                  - "es:ListDomainNames"
                  - "es:ListTags"
                  - "events:CreateEventBus"
                  - "fsx:DescribeFileSystems"
                  - "fsx:ListTagsForResource"
                  - "health:DescribeAffectedEntities"
                  - "health:DescribeEventDetails"
                  - "health:DescribeEvents"
                  - "iam:ListAccountAliases"
                  - "kinesis:Describe*"
                  - "kinesis:List*"
                  - "lambda:List*"
                  - "logs:DeleteSubscriptionFilter"
                  - "logs:DescribeDeliveries"
                  - "logs:DescribeDeliverySources"
                  - "logs:DescribeLogGroups"
                  - "logs:DescribeLogStreams"
                  - "logs:DescribeSubscriptionFilters"
                  - "logs:FilterLogEvents"
                  - "logs:GetDeliveryDestination"
                  - "logs:PutSubscriptionFilter"
                  - "logs:TestMetricFilter"
                  - "network-firewall:DescribeLoggingConfiguration"
                  - "network-firewall:ListFirewalls"
                  - "oam:ListAttachedLinks"
                  - "oam:ListSinks"
                  - "organizations:Describe*"
                  - "organizations:List*"
                  - "rds:Describe*"
                  - "rds:List*"
                  - "redshift-serverless:ListNamespaces"
                  - "redshift:DescribeClusters"
                  - "redshift:DescribeLoggingStatus"
                  - "route53:List*"
                  - "route53resolver:ListResolverQueryLogConfigs"
                  - "s3:GetBucketLocation"
                  - "s3:GetBucketLogging"
                  - "s3:GetBucketNotification"
                  - "s3:GetBucketTagging"
                  - "s3:ListAllMyBuckets"
                  - "s3:PutBucketNotification"
                  - "ses:Get*"
                  - "ses:List*"
                  - "sns:GetSubscriptionAttributes"
                  - "sns:List*"
                  - "sns:Publish"
                  - "sqs:ListQueues"
                  - "ssm:GetServiceSetting"
                  - "ssm:ListCommands"
                  - "states:DescribeStateMachine"
                  - "states:ListStateMachines"
                  - "support:DescribeTrustedAdvisor*"
                  - "support:RefreshTrustedAdvisorCheck"
                  - "tag:GetResources"
                  - "tag:GetTagKeys"
                  - "tag:GetTagValues"
                  - "timestream:DescribeEndpoints"
                  - "wafv2:ListLoggingConfigurations"
                  - "xray:BatchGetTraces"
                  - "xray:GetTraceSummaries"
  # Lambda function to dynamically attach permissions from DataDog API
  DatadogAttachIntegrationPermissionsLambdaExecutionRole:
    Type: AWS::IAM::Role
    Condition: ShouldInstallSecurityAuditPolicy
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      Policies:
        - PolicyName: !Sub "datadog-aws-integration-iam-permissions-${IAMRoleName}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - iam:CreatePolicy
                  - iam:DeletePolicy
                  - iam:AttachRolePolicy
                  - iam:DetachRolePolicy
                Resource: 
                  - !Sub arn:aws:iam::${AWS::AccountId}:role/${IAMRoleName}
                  - !Sub arn:aws:iam::${AWS::AccountId}:policy/datadog-aws-integration-iam-permissions-*
                  - !Sub "arn:${AWS::Partition}:iam::aws:policy/SecurityAudit"
  DatadogAttachIntegrationPermissionsFunction:
    Type: AWS::Lambda::Function
    Condition: ShouldInstallSecurityAuditPolicy
    Properties:
      Description: "A function to attach Datadog AWS integration permissions to an IAM role."
      Role: !GetAtt DatadogAttachIntegrationPermissionsLambdaExecutionRole.Arn
      Handler: "index.handler"
      LoggingConfig:
        ApplicationLogLevel: "INFO"
        LogFormat: "JSON"
      Runtime: "python3.11"
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import logging
          import hashlib
          from urllib.request import Request
          import urllib
          import cfnresponse
          import boto3

          LOGGER = logging.getLogger()
          LOGGER.setLevel(logging.INFO)
          API_CALL_SOURCE_HEADER_VALUE = "cfn-iam-permissions"
          MAX_POLICY_SIZE = 6144  # Maximum characters for AWS managed policy document
          BASE_POLICY_PREFIX = "datadog-aws-integration-iam-permissions"

          class DatadogAPIError(Exception):
              pass

          def get_policy_arn(account_id, policy_name):
              """Generate a policy ARN."""
              return f"arn:aws:iam::{account_id}:policy/{policy_name}"

          def create_smart_chunks(permissions):
              """Create chunks based on character limit rather than permission count."""
              chunks = []
              current_chunk = []
              
              # Base policy structure size (without permissions)
              base_policy = {
                  "Version": "2012-10-17",
                  "Statement": [
                      {
                          "Effect": "Allow",
                          "Action": [],
                          "Resource": "*"
                      }
                  ]
              }
              base_size = len(json.dumps(base_policy, separators=(',', ':')))
              
              for permission in permissions:
                  # Calculate size if we add this permission
                  test_chunk = current_chunk + [permission]
                  test_policy = {
                      "Version": "2012-10-17",
                      "Statement": [
                          {
                              "Effect": "Allow",
                              "Action": test_chunk,
                              "Resource": "*"
                          }
                      ]
                  }
                  test_size = len(json.dumps(test_policy, separators=(',', ':')))
                  
                  # If adding this permission would exceed the limit, start a new chunk
                  if test_size > MAX_POLICY_SIZE and current_chunk:
                      chunks.append(current_chunk)
                      current_chunk = [permission]
                      current_size = len(json.dumps({
                          "Version": "2012-10-17",
                          "Statement": [
                              {
                                  "Effect": "Allow",
                                  "Action": [permission],
                                  "Resource": "*"
                              }
                          ]
                      }, separators=(',', ':')))
                  else:
                      current_chunk.append(permission)
                      current_size = test_size
              
              # Add the last chunk if it has permissions
              if current_chunk:
                  chunks.append(current_chunk)
              
              return chunks

          def fetch_permissions_from_datadog():
              """Fetch permissions from Datadog API."""
              api_url = f"https://api.datadoghq.com/api/v2/integration/aws/iam_permissions"
              headers = {
                  "Dd-Aws-Api-Call-Source": API_CALL_SOURCE_HEADER_VALUE,
              }
              request = Request(api_url, headers=headers)
              request.get_method = lambda: "GET"
              
              response = urllib.request.urlopen(request)
              json_response = json.loads(response.read())
              if response.getcode() != 200:
                  error_message = json_response.get('errors', ['Unknown error'])[0]
                  raise DatadogAPIError(f"Datadog API error: {error_message}")
              
              return json_response["data"]["attributes"]["permissions"]

          def cleanup_existing_policies(iam_client, role_name, account_id, base_policy_name, max_policies=20):
              """Clean up existing policies with both old and new naming patterns"""
              
              # Clean up new dynamic policies (datadog-aws-integration-iam-permissions-part{N})
              for i in range(max_policies):
                  policy_name = f"{BASE_POLICY_PREFIX}-part{i+1}"
                  policy_arn = get_policy_arn(account_id, policy_name)
                  try:
                      iam_client.detach_role_policy(
                          RoleName=role_name,
                          PolicyArn=policy_arn
                      )
                  except iam_client.exceptions.NoSuchEntityException:
                      # Policy to detach doesn't exist
                      pass
                  except Exception as e:
                      LOGGER.error(f"Error detaching policy {policy_name}: {str(e)}")

                  try:
                      iam_client.delete_policy(
                          PolicyArn=policy_arn
                      )
                  except (iam_client.exceptions.NoSuchEntityException, iam_client.exceptions.DeleteConflictException):
                      # Policy to delete doesn't exist
                      pass
                  except Exception as e:
                      LOGGER.error(f"Error deleting policy {policy_name}: {str(e)}")
              
              # Clean up old hardcoded managed policies ({IAMRoleName}-ManagedPolicy-{N})
              # Extract role name from the base_policy_name for old policy cleanup
              role_name_from_hash = role_name  # We have the role name directly
              for i in range(1, 5):  # Old template had ManagedPolicy-1 through ManagedPolicy-4
                  old_policy_name = f"{role_name_from_hash}-ManagedPolicy-{i}"
                  old_policy_arn = get_policy_arn(account_id, old_policy_name)
                  try:
                      iam_client.detach_role_policy(
                          RoleName=role_name,
                          PolicyArn=old_policy_arn
                      )
                      LOGGER.info(f"Detached old policy: {old_policy_name}")
                  except iam_client.exceptions.NoSuchEntityException:
                      # Policy to detach doesn't exist
                      pass
                  except Exception as e:
                      LOGGER.error(f"Error detaching old policy {old_policy_name}: {str(e)}")

                  try:
                      iam_client.delete_policy(
                          PolicyArn=old_policy_arn
                      )
                      LOGGER.info(f"Deleted old policy: {old_policy_name}")
                  except (iam_client.exceptions.NoSuchEntityException, iam_client.exceptions.DeleteConflictException):
                      # Policy to delete doesn't exist
                      pass
                  except Exception as e:
                      LOGGER.error(f"Error deleting old policy {old_policy_name}: {str(e)}")

          def handle_delete(event, context, role_name, account_id, base_policy_name):
              """Handle stack deletion."""
              iam_client = boto3.client('iam')
              try:
                  cleanup_existing_policies(iam_client, role_name, account_id, base_policy_name)
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={})
              except Exception as e:
                  LOGGER.error(f"Error deleting policy: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={"Message": str(e)})

          def handle_create_update(event, context, role_name, account_id, base_policy_name):
              """Handle stack creation or update."""
              try:
                  # Fetch and smart chunk permissions based on character limits
                  permissions = fetch_permissions_from_datadog()
                  permission_chunks = create_smart_chunks(permissions)
                  
                  LOGGER.info(f"Created {len(permission_chunks)} policy chunks from {len(permissions)} permissions")
                  
                  # Clean up existing policies
                  iam_client = boto3.client('iam')
                  cleanup_existing_policies(iam_client, role_name, account_id, base_policy_name)

                  # Create and attach new policies
                  for i, chunk in enumerate(permission_chunks):
                      # Create policy
                      policy_name = f"{BASE_POLICY_PREFIX}-part{i+1}"
                      policy_document = {
                          "Version": "2012-10-17",
                          "Statement": [
                              {
                                  "Effect": "Allow",
                                  "Action": chunk,
                                  "Resource": "*"
                              }
                          ]
                      }
                      
                      # Verify policy size before creating
                      policy_json = json.dumps(policy_document, separators=(',', ':'))
                      policy_size = len(policy_json)
                      LOGGER.info(f"Creating policy {policy_name} with {len(chunk)} permissions ({policy_size} characters)")
                      
                      if policy_size > MAX_POLICY_SIZE:
                          LOGGER.error(f"Policy {policy_name} exceeds size limit: {policy_size} > {MAX_POLICY_SIZE}")
                          raise Exception(f"Policy size exceeds AWS limit: {policy_size} > {MAX_POLICY_SIZE}")
                      
                      policy = iam_client.create_policy(
                          PolicyName=policy_name,
                          PolicyDocument=policy_json
                      )
                      
                      # Attach policy to role
                      iam_client.attach_role_policy(
                          RoleName=role_name,
                          PolicyArn=policy['Policy']['Arn']
                      )

                  # probably not needed########################################################
                  # # Attach the SecurityAudit policy if ResourceCollectionPermissions is enabled
                  # if event["ResourceProperties"].get("ResourceCollectionPermissions", "false") == "true":
                  #     iam_client.attach_role_policy(
                  #         RoleName=role_name,
                  #         PolicyArn="arn:{partition}:iam::aws:policy/SecurityAudit".format(partition=event["ResourceProperties"]["Partition"])
                  #     )
                  #########################################################
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={})
              except Exception as e:
                  LOGGER.error(f"Error creating/attaching policy: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={"Message": str(e)})

          def handler(event, context):
              LOGGER.info("Event received: %s", json.dumps(event))
              
              role_name = event['ResourceProperties']['DatadogIntegrationRole']
              account_id = event['ResourceProperties']['AccountId']
              
              if event['RequestType'] == 'Delete':
                  handle_delete(event, context, role_name, account_id, BASE_POLICY_PREFIX)
              else:
                  handle_create_update(event, context, role_name, account_id, BASE_POLICY_PREFIX)
  DatadogAttachIntegrationPermissionsFunctionTrigger:
    Type: Custom::DatadogAttachIntegrationPermissionsFunctionTrigger
    Condition: ShouldInstallSecurityAuditPolicy
    Properties:
      ServiceToken: !GetAtt DatadogAttachIntegrationPermissionsFunction.Arn
      DatadogIntegrationRole: !Ref IAMRoleName
      AccountId: !Ref AWS::AccountId
      Partition: !Ref AWS::Partition
      ResourceCollectionPermissions: !Ref ResourceCollectionPermissions
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Required
        Parameters:
          - ExternalId
          - IAMRoleName
      - Label:
          default: Optional
        Parameters:
          - CloudSecurityPostureManagementPermissions
          - DdAWSAccountId
